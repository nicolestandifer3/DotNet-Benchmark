using System;
using System.Diagnostics;
using System.Threading;
using System.Runtime.CompilerServices;
using BenchmarkDotNet;
using BenchmarkDotNet.Characteristics;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Extensions;
using BenchmarkDotNet.Helpers;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Engines;
$TargetTypeNamespace$
$TargetMethodReturnTypeNamespace$

$AdditionalLogic$

namespace BenchmarkDotNet.Autogenerated
{
    public class Program : global::$TargetTypeName$
    {
        public static int Main(string[] args)
        {
            try
            {
                Program instance = new Program();
                $ParamsContent$

                instance.setupAction();
                instance.mainAction();
                instance.cleanupAction();

                System.Console.WriteLine();
                foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
                {
                    System.Console.WriteLine("// {0}", infoLine);
                }
                var set = $JobSetDefinition$;
                var job = Job.Parse(set, false);
                System.Console.WriteLine("// Job: {0}", job.DisplayInfo);
                System.Console.WriteLine();


                var engine = new BenchmarkDotNet.Engines.Engine(instance.IdleMultiAction, instance.MainMultiAction)
                {
                    SetupAction = instance.setupAction,
                    CleanupAction = instance.cleanupAction,
                    TargetJob = job,
                    OperationsPerInvoke = $OperationsPerInvoke$,
                };
                engine.Run();

                return 0;
            }
            catch (Exception ex)
            {
                System.Console.WriteLine(ex);
                return -1;
            }
        }

        public Program()
        {
            setupAction = $SetupMethodName$;
            cleanupAction = $CleanupMethodName$;
            idleAction = Idle;
            mainAction = $TargetMethodDelegate$;
        }

        private Action setupAction;
        private Action cleanupAction;
        private $IdleMethodDelegateType$ idleAction;
        private $TargetMethodDelegateType$ mainAction;

        private $IdleMethodReturnType$ Idle()
        {
            $IdleImplementation$
        }

#if $HasReturnValue$

        private Consumer consumer = new Consumer();

        private void IdleMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(idleAction());@Unroll@
            }
        }

        private void MainMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(mainAction());@Unroll@
            }
        }

#else

        private void IdleMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                idleAction();@Unroll@
            }
        }

        private void MainMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                mainAction();@Unroll@
            }
        }

#endif
    }
}
