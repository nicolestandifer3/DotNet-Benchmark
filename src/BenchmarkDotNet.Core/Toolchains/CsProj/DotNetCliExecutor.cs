using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using BenchmarkDotNet.Characteristics;
using BenchmarkDotNet.Diagnosers;
using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Extensions;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Loggers;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Toolchains.DotNetCli;
using BenchmarkDotNet.Toolchains.Results;

namespace BenchmarkDotNet.Toolchains.CsProj
{
    public class DotNetCliExecutor : IExecutor
    {
        public ExecuteResult Execute(BuildResult buildResult, Benchmark benchmark, ILogger logger, IResolver resolver, IDiagnoser diagnoser = null)
        {
            ConsoleHandler.EnsureInitialized(logger);

            try
            {
                return Execute(benchmark, logger, buildResult.ArtifactsPaths.BinariesDirectoryPath, diagnoser);
            }
            finally
            {
                ConsoleHandler.Instance.ClearProcess();
            }
        }

        private ExecuteResult Execute(Benchmark benchmark, ILogger logger, string workingDirectory, IDiagnoser diagnoser)
        {
            var args = BuildArgs(diagnoser);
            using (var process = new Process { StartInfo = DotNetCliCommandExecutor.BuildStartInfo(workingDirectory, args) })
            {
                var loggerWithDiagnoser = new SynchronousProcessOutputLoggerWithDiagnoser(logger, process, diagnoser, benchmark);

                ConsoleHandler.Instance.SetProcess(process);

                process.Start();

                process.EnsureHighPriority(logger);
                if (benchmark.Job.Env.HasValue(EnvMode.AffinityCharacteristic))
                {
                    process.EnsureProcessorAffinity(benchmark.Job.Env.Affinity);
                }

                loggerWithDiagnoser.ProcessInput();

                process.WaitForExit(); // should we add timeout here?

                if (process.ExitCode == 0)
                {
                    return new ExecuteResult(true, process.ExitCode, loggerWithDiagnoser.LinesWithResults, loggerWithDiagnoser.LinesWithExtraOutput);
                }

                return new ExecuteResult(true, process.ExitCode, new string[0], new string[0]);
            }
        }

        private static string BuildArgs(IDiagnoser diagnoser)
        {
            var args = new StringBuilder("BenchmarkDotNet.Autogenerated.dll");

            if (diagnoser != null)
            {
                args.Append($" {Engine.Signals.DiagnoserIsAttachedParam}");
            }

            return args.ToString();
        }
    }
}