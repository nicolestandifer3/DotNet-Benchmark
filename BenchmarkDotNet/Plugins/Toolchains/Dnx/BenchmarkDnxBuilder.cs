#if DNX451
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using BenchmarkDotNet.Plugins.Toolchains.Results;
using Microsoft.Dnx.Compilation;
using Microsoft.Dnx.Compilation.Caching;
using Microsoft.Dnx.Runtime;
using Microsoft.Dnx.Runtime.Internal;
using Microsoft.Extensions.PlatformAbstractions;
using System.Runtime.Versioning;
using BenchmarkDotNet.Extensions;

namespace BenchmarkDotNet.Plugins.Toolchains.Dnx
{
    internal class BenchmarkDnxBuilder : IBenchmarkBuilder
    {
        public BenchmarkBuildResult Build(BenchmarkGenerateResult generateResult, Benchmark benchmark)
        {
            const string projectName = "BenchmarkDotNet.Autogenerated";
            const string configuration = "Release";
            const string aspect = null; // keep it null or string.Empy

            // https://github.com/aspnet/dnx => this repo is a great source of knowledge
            // you should take a look at Microsoft.Dnx.Compilation.LibraryExporter.ExportProject()

            var projectJsonPath = Path.Combine(generateResult.DirectoryPath, BenchmarkDnxGenerator.ProjectFileName);
            var outputPath = generateResult.DirectoryPath;

            var projectJsonContent = File.ReadAllText(projectJsonPath);
            var project = ProjectUtilities.GetProject(projectJsonContent, projectName, projectJsonPath);
            var targetFramework = project.GetTargetFrameworks().Single().FrameworkName;

            var runtimeEnvironment = PlatformServices.Default.Runtime;
            var benchmarkApplicationEnvironment = new ApplicationEnvironment(project, targetFramework, configuration, hostEnvironment: null);

            var defaultLoadContext = PlatformServices.Default.AssemblyLoadContextAccessor.Default;
            var compilationEngineContext = new CompilationEngineContext(benchmarkApplicationEnvironment, runtimeEnvironment, defaultLoadContext, new CompilationCache());
            var compilationEngine = new CompilationEngine(compilationEngineContext);
            var libraryExporter = compilationEngine.CreateProjectExporter(project, targetFramework, configuration);
            var projectCompiler = compilationEngine.GetCompiler(Project.DefaultRuntimeCompiler, defaultLoadContext);
            var compilationProjectContext = ToCompilationContext(project, targetFramework, configuration, aspect);

            var allDependencies = libraryExporter.GetAllDependencies(project.Name, aspect);
            // this is the crucial part: library exporter could not resolve our dependencies so we must add them on our own
            AddAllRequiredMetadataReferences(allDependencies.MetadataReferences, defaultLoadContext, "BenchmarkDotNet");
            AddAllRequiredMetadataReferences(allDependencies.MetadataReferences, defaultLoadContext, benchmark.Target.Type.Assembly.GetName().Name);

            var metadataProjectReference = projectCompiler.CompileProject(
                compilationProjectContext,
                () => allDependencies,
                () => CompositeResourceProvider.Default.GetResources(project));

            var diagnosticResult = metadataProjectReference.EmitAssembly(outputPath);

            Exception diagnosticException = diagnosticResult.Success
                ? null
                : new Exception(string.Join("\r\n", diagnosticResult.Diagnostics.Select(message => message.Message)));

            return new BenchmarkBuildResult(generateResult, diagnosticResult.Success, diagnosticException);
        }

        private void AddAllRequiredMetadataReferences(IList<IMetadataReference> metadataReferences, IAssemblyLoadContext loadContext, string referenceName)
        {
            if (metadataReferences.Any(reference => reference.Name == referenceName))
            {
                return;
            }

            var requiredAssembly = loadContext.Load(referenceName);
            var assemblyLocation = requiredAssembly.TryGetLocation(referenceName);
            metadataReferences.Add(new MetadataFileReference(referenceName, assemblyLocation));

            //requiredAssembly.GetReferencedAssemblies()
            //    .Select(assemblyName => loadContext.Load(assemblyName))
            //    .Where(assembly => !string.IsNullOrEmpty(assembly.Location))
            //    .ForEach(assembly => 
            //        metadataReferences.Add(new MetadataFileReference(assembly.GetName().Name, assembly.Location)));
        }

        // copied from Microsoft.Dnx.Compilation.ProjectExtensions
        private static CompilationProjectContext ToCompilationContext(Project self, FrameworkName frameworkName, string configuration, string aspect)
        {
            return new CompilationProjectContext(
                new CompilationTarget(self.Name, frameworkName, configuration, aspect),
                self.ProjectDirectory,
                self.ProjectFilePath,
                self.Title,
                self.Description,
                self.Copyright,
                self.Version.ToString(),
                self.AssemblyFileVersion,
                self.EmbedInteropTypes,
                new CompilationFiles(
                    self.Files.PreprocessSourceFiles,
                    self.Files.SourceFiles),
                self.GetCompilerOptions(frameworkName, configuration));
        }
    }
}
#endif